# 第十一章：复制与一致性

	在继续讨论共识算法和原子保证算法之前，我们先汇总一下深入理解他们需要的最后一部分内容：一致性模型。一致性模型非常重要，因为它们解释了存在多个数据副本时系统的可见性语义和行为。

	容错是系统在组件发生故障时还可以继续正确运行的一个属性。要使系统具有容错能力并不是一件容易的事，并且可能很难在现有系统中增加容错能力。主要目标是从系统中消除单点故障，并确保我们的关键组件有冗余性。通常，冗余对于用户来说是完全透明的。

	可以通过存储多个数据副本来让系统继续正常地运行，因此当一台计算机发生故障时，另一台计算机可以用作故障转移。在单数据源的系统（例如，主数据库/副本数据库）中，可以通过将从副本提升为新的主副本来明确地进行故障转移。其他系统不需要显式重新配置，并且可以通过在读写期间收集来自多个参与者的响应来确保数据的一致性。

	数据复制是一种通过在系统中维护多个数据副本引入冗余的方法。但是，由于原子地更新多个副本是一个共识的问题[MILOSEVIC11]，因此数据库中的每个操作如果都以原子的方式在多个副本间执行的话那么执行的代价是相当高的。我们可以探索一些更有效和灵活的方法，以使数据从用户的角度看是一致的，同时允许参与者之间有一定程度的差异。

	复制在多数据中心部署中尤其重要。在这种情况下，基于地理位置的复制具有多种用途：通过提供冗余性，它可以提高可用性以及承受一个或多个数据中心出现故障。通过将数据副本放置在更靠近客户端的地方，还有助于减少延迟。

	修改数据记录后，必须相应地更新其副本。当谈到复制时，我们最关心的是三个事件：写入，副本更新和读取。这些操作触发客户端启动的一系列事件。从客户端的角度来看，在某些情况下更新副本可能发生在写入完成后，但客户端看到的操作必须是特定顺序的。



实现可用性

	我们讨论了分布式系统的弊端，并认识到了许多可能出错的地方。在现实世界中，节点并不可能总是可用的或能够相互通信。但是，间歇性故障不应该影响可用性：从用户的角度来看，整个系统必须像什么事情都没有发生一样继续正常地运行。

	系统可用性是一个极其重要的属性：在软件工程中，我们始终追求高可用性，并尽量减少停机时间。工程团队吹嘘他们的正常运行时间的指标。我们非常在乎可用性，原因有几个：软件已经成为我们社会不可缺少的一部分，没有它，许多重要的事情就不可能实现：银行交易，通讯，旅行等等。

	对于公司而言，缺乏可用性可能意味着失去客户或损失金钱：如果网站宕机，则无法在网上商店购物；如果银行的网站没有响应，则无法进行银行转账。

	为了实现系统的高可用，我们需要设计一种能够处理一个或多个参与者节点故障或不可用的系统。因此，我们需要引入冗余和复制。但是，一旦添加了冗余，我们将面临在多个数据副本间保持同步的问题，并且必须实现恢复机制。



臭名昭著的CAP

	可用性是一种衡量系统能够成功处理每个请求的属性。可用性理论定义是指最终的响应，但在实际系统中，我们希望避免无限长地等待服务响应。

	理想情况下，我们希望每个操作都保持一致性。一致性在这里定义为原子或线性化一致性（请参见“线性化”）。

	线性化的历史记录可以表示为一系列保留原始操作顺序的瞬时操作。线性化使系统可能存在的状态推理起来更加简单，并让分布式系统看起来像运行在单台计算机上一样。

	我们希望在容忍网络分区的同时实现一致性和可用性。网络可以分区成多个部分，不同分区的进程之间是无法进行通信的：无法在分区节点之间发送消息。

	可用性要求任何无故障的节点都可以交付结果，而一致性要求结果必须线性化。埃里克·布鲁尔（Eric Brewer）提出的CAP猜想讨论了一致性，可用性和分区容错性[BREWER00]之间的取舍。

	在异步系统中无法满足可用性要求，我们也无法实现一种在网络分区的情况下还能够同时满足可用性和一致性的系统[GILBERT02]。 我们可以构建一种在保证强一致性同时尽可能可用的系统，或者在保证可用性的同时尽可能一致的系统。[GILBERT12]。 尽可能可用或尽可能一致是指如果系统运行正常的情况下需要保证一致性或可用性，但在网络分区的情况下，可以允许弱一致性或部分不可用。

	也就是说，CAP描述了系统在不同方面的不同取舍：

- 分区容错性和一致性
  CP系统会优先保证数据一致，所以会拒绝服务。
- 分区容错性和可用性
  AP系统会优先保证服务可用，但数据可能不是一致的。



	说CP系统是共识算法的一种实现，是因为它的实现也需要大多数节点参与：为了始终保持一致性，所以在网络分区的情况下可能是不可用的。 对于AP系统来说，只要一个副本正常，数据库就能够提供写入和读取服务，它可能会丢失数据或产生不一致的结果。

	CAPELC推测[ABADI12]是CAP的扩展，它指出，在发生网络分区的情况下，可以在一致性和可用性（PAC）之间进行选择。 否则（E）即使系统正常运行，我们仍然必须在延迟和一致性之间做出选择。



小心使用CAP

	请务必注意，CAP讨论的是网络分区，而不是节点崩溃或任何其他类型的故障（例如崩溃恢复）。一个和群集分区的节点可以提供的数据不一致的服务，但是崩溃的节点是无法提供服务的。一方面，这意味着不必让任何节点都面对一致性问题。另一方面，在现实世界中并非如此：存在许多不同的故障场景（其中一些可以通过网络分区进行模拟）。(tocheck)

	CAP意味着即使所有节点都在运行，我们也可能会遇到一致性问题，因为可能它们之间存在连接性问题，因此我们希望每个非故障节点都能正确响应请求，而不考虑有多少个节点宕机。

	CAP猜想有时以三角形表示，就好像我们可以扭动三角形的三条边一样。然而，尽管我们可以旋钮并在一致性和可用性做取舍，但分区容忍性是我们无法进行取舍的[HALE10]。

提示

CAP中的一致性定义与ACID（参见第5章）的一致性定义是完全不同的概念。 ACID一致性描述的是事务一致性：事务将数据库从一种有效状态转移到另一种有效状态，并保持所有数据库不变性（例如唯一性约束和引用完整性）。 在CAP中，一致性指的是操作的原子性（操作要么全部要成功要么全部要失败）和一致性（操作永远不会使数据处于不一致状态）。



	CAP中的可用性也不同于上述的高可用性[KLEPPMANN15]。 CAP的可用性定义对操作延迟没有任何限制。 此外，与CAP相比，数据库的可用性并不需要每个非故障节点来响应每个请求。

	CAP猜想用于解释分布式系统，发生故障的原因并评估可能的情况，但请务必记住，放弃一致性和提供不可预测的结果之间存在一条很好的界限。（tocheck）

	数据库声称在可用性方面，如果使用正确，那么可以提供来自大多数正常节点的一致性的结果数据。当然，还有更复杂的故障场景，CAP猜想只是一个经验法则，并不一定能说明真正的原因。1



收获和产出

	CAP猜想以严格约束的方式来讨论一致性和可用性：线性一致性和系统能够最终响应每个请求的能力。 这种严格约束迫使我们在两个属性之间进行艰难的取舍。 然而有的应用程序可能会受益于稍微宽松的约束，我们也可以以宽松的方式考虑这些属性。

	系统可以提供宽松的保证，而不是严格的一致性或可用性。 我们可以定义两个可调指标：收获和产出，在两者之间选择仍然可以构成正确的行为[FOX99]:

收获

	对查询完成的定义：如果查询需要返回100行数据，但是由于某些节点不可用而只能获取到99行，那么返回这99行数据总比不返回任何数据好。

产出

	产出指定了成功完成的请求数与尝试的请求总数的比例。 产出不同于正常运行时间，例如，一个繁忙但并没有终止运行的节点，也是无法处理请求的。

	对权衡可用性或一致性属性的定义从绝对性换成相对性。 我们可以定义更低的收获标准来取得更高的产出比例，并允许某些请求返回不完整的数据。 提高产出的一种方法是仅从可用分区中返回查询结果（请参见“数据库分区”）。 例如，如果存储某些用户记录的节点出现故障，其他节点仍然可以继续为其他用户提供请求。 或者，我们可以要求关键应用程序请求的数据全部返回，但允许其他请求有所偏差。

	在收获和产出之间进行定义，衡量和有意识地选择，有助于我们构建对失败容忍更弹性的系统。





共享内存

	对于客户端来说，存储数据的分布式系统就像共享存储的单点系统一样。节点间的通信和消息传递被抽象化并发生在幕后。 所以会产生共享内存的错觉。

	可以读取或写入的单个存储单元通常称为寄存器。 我们可以将分布式数据库中的共享内存视为一组寄存器。

	我们通过调用和完成事件来识别每个操作。 如果在完成调用一个操作之前崩溃，则我们将操作的调用定义为失败。 如果一个操作的调用和完成事件都在另一个操作被调用之前发生，我们说这个操作在另一个操作之前，并且这两个操作是顺序的。 否则，我们它们是并发的。



在图11-1中，可以看到进程P1和P2执行不同的操作：

- a）进程P2执行的操作在进程P1执行的操作完成之后开始，并且两个操作是顺序的。
- b）这两个操作之间有重叠，因此这些操作是并发的。
- c）P2执行的操作在P1执行的操作之后开始执行并在它完成之前完成。 这些操作也是并发的。



Figure 11-1. Sequential and concurrent operatio



	多个读取器或写入器可以同时访问寄存器。 对寄存器的读写操作不是瞬间完成的。

	由不同进程执行的并发读/写操作不是串行的：根据寄存器在操作过程重叠时的行为，它们的顺序可能不同，并可能产生不同的结果。 根据寄存器处理并行操作的行为，我们区分三种类型的寄存器：

- 安全
  在并发写入操作时候如果读取安全寄存器可能会返回寄存器范围内的任意值（这听起来不太实际，但是可能描述了不强制执行顺序的异步系统的语义）。 存有二进制值的安全寄存器在写入的同时进行的读取可能会得到不确定的值（即返回结果是写入前的值或写入后的值）。
- 常规
  对于常规寄存器，我们有更强的保证：读操作只能返回最近完成的写操作的值，或者返回与当前读操作重叠的写操作的值。 在这种情况下，系统具有某种顺序概念，但是写入结果并非同时对所有读可见（例如，这可能发生在具有复制功能数据库中，在主服务接受写入并将其复制到从服务，然后读取从服务，主从会有数据差异，不同的从服务也会因为复制时间不一样导致返回的读取数据不一样）。
- 原子
  原子寄存器保证线性化：可以看做每个写入操作都是瞬间完成的，在此之前的读取操作都返回旧值，在此之后的读取操作都返回新值。 原子性是简化系统状态推理的基本特性。












